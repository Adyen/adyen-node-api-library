{{>licenseInfo}}

import getJsonResponse from "../../helpers/getJsonResponse";
import Service from "../../service";
/* tslint:disable:no-unused-locals */
{{#imports}}
import { {{classname}} } from '{{filename}}';
{{/imports}}
// TODO: query string $import_request_options
import ManagementResource from "../resource/management/managementResource";
import { ObjectSerializer } from "../../typings/management/models";

{{#operations}}

export class {{classname}} extends Service {
{{#operation}}
    /**
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{paramName}} {{description}}
     {{/allParams}}
     */
    public async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options: {headers: {[name: string]: string}} = {headers: {}}): Promise<{{#returnType}}{{{.}}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
        const localVarPath = "{{{path}}}"{{#pathParams}}
            .replace('{' + '{{baseName}}' + '}', encodeURIComponent(String({{paramName}}))){{/pathParams}};
        const resource = new ManagementResource(this, localVarPath);
        const response = await getJsonResponse<{{#bodyParam}}{{{dataType}}}{{/bodyParam}}{{^bodyParam}}string{{/bodyParam}}, {{#returnType}}{{{.}}}{{/returnType}}{{^returnType}}void{{/returnType}}>(
            resource,
            $request_value,
            { $call_args }
        );

        {{#returnType}}
        return ObjectSerializer.deserialize(response, "{{{.}}}");
        {{/returnType}}
    }

// DEFAULT

    public async {{nickname}} ({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; {{#returnType}}body: {{{.}}}; {{/returnType}}{{^returnType}}body?: any; {{/returnType}} }> {
        const localVarPath = this.basePath + '{{{path}}}'{{#pathParams}}
            .replace('{' + '{{baseName}}' + '}', encodeURIComponent(String({{paramName}}))){{/pathParams}};
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

{{#allParams}}
{{#required}}
        // verify required parameter '{{paramName}}' is not null or undefined
        if ({{paramName}} === null || {{paramName}} === undefined) {
            throw new Error('Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
        }

{{/required}}
{{/allParams}}
{{#queryParams}}
        if ({{paramName}} !== undefined) {
            localVarQueryParameters['{{baseName}}'] = ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}");
        }

{{/queryParams}}
{{#headerParams}}
        localVarHeaderParams['{{baseName}}'] = ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}");
{{/headerParams}}
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarRequestOptions: localVarRequest.Options = {
            method: '{{httpMethod}}',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
{{#bodyParam}}
            body: ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}")
{{/bodyParam}}
        };

        return interceptorPromise.then(() => {
            return new Promise<{ response: http.IncomingMessage; {{#returnType}}body: {{{.}}}; {{/returnType}}{{^returnType}}body?: any; {{/returnType}} }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            {{#returnType}}
                            body = ObjectSerializer.deserialize(body, "{{{.}}}");
                            {{/returnType}}
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
{{/operation}}
}
{{/operations}}
